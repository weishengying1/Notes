# TCPStore

TCPStore 是一个中心化的键值存储服务，主要用于存储简单的数据类型（如字符串、整数等），通常由一个主进程（rank 0）充当服务器，其他进程作为客户端连接到这个服务器。

`在 vllm 的使用中，使用它封装了一个自定义 StatelessProcessGroup 类，用来辅助构建一个 NCCL 通信 group，StatelessProcessGroup 基于TCPStore把 nccl unique_id 号广播到 nccl group 内所有进程完成初始化。`



## TCPStore 的架构
1. TCPStore 是一个客户端-服务器架构：

> 服务器端：由主进程（通常是 rank 0）启动，负责维护键值存储的实际数据。

> 客户端：其他进程（rank > 0）作为客户端，通过 TCP 协议与服务器通信，执行 set、get 等操作。

> 当一个进程调用 set 时，数据会被发送到服务器端，由服务器端存储并管理。其他进程通过 get 操作从服务器端获取数据。

2. 数据存储的位置
> 服务器端存储：

> 服务器端维护一个本地的键值存储（通常是一个哈希表或字典），用于存储所有 set 操作提交的键值对。

> 当客户端调用 set(key, value) 时，客户端会通过 TCP 协议将键值对发送到服务器端，服务器端将其存储在本地的键值存储中。

> `服务器端是唯一实际存储数据的地方，客户端不存储数据。`

> 客户端缓存（可选）：

> 为了提高性能，客户端可能会缓存一些常用的键值对，但缓存的一致性由应用层保证。

> 默认情况下，每次 get 操作都会从服务器端获取最新数据。

3. set 操作的底层流程
> 当一个进程调用 set(key, value) 时，以下是底层的执行流程：

> 步骤 1：客户端发送请求
客户端将 set 操作封装为一个网络请求，包含以下信息：

> 操作类型（set）。

> 键（key）。

> 值（value）。

> 客户端通过 TCP 协议将请求发送到服务器端。

> 步骤 2：服务器端处理请求
服务器端接收到请求后，解析操作类型、键和值。

> 服务器端将键值对存储在本地的键值存储中（例如一个哈希表）。

> 如果键已经存在，服务器端会覆盖旧值。

> 步骤 3：服务器端返回响应
服务器端向客户端发送一个确认响应，表示 set 操作已成功完成。

> 步骤 4：客户端处理响应
客户端接收到确认响应后，set 操作完成。

4. get 操作的底层流程
> 当一个进程调用 get(key) 时，以下是底层的执行流程：

> 步骤 1：客户端发送请求
客户端将 get 操作封装为一个网络请求，包含以下信息：

> 操作类型（get）。

> 键（key）。

> 步骤 2：服务器端处理请求
服务器端接收到请求后，解析操作类型和键。

> 服务器端从本地的键值存储中查找键对应的值。

> 如果键不存在，服务器端会返回一个错误或默认值。

> 步骤 3：服务器端返回响应
服务器端将找到的值（或错误信息）封装为响应，发送回客户端。

> 步骤 4：客户端处理响应
客户端接收到响应后，解析出值并返回给调用者。

> 5. 数据一致性与同步
一致性：

> 由于所有 set 操作都通过服务器端进行，服务器端是唯一的数据源，因此保证了数据的一致性。

> 所有客户端通过 get 操作从服务器端获取数据，确保获取的是最新值。

> 同步：

> TCPStore 提供了 wait(keys) 方法，用于阻塞客户端，直到指定的键被设置。

> 这是通过客户端轮询服务器端实现的，直到服务器端返回确认。

# FILEStore 和 HASHStore
FILEStore 使用文件系统作为存储后端，进程通过读写共享文件来通信。文件可以是本地文件或网络文件系统（如 NFS）。

HASHStore 是基于内存的键值存储，数据存储在内存中，适合快速访问。通常用于单机多进程或多机多进程的分布式训练。